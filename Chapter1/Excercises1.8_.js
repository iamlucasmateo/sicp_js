// Notes: Factorial functions
function factorial_recursive(n) {
    return n === 0 ? 1 : n*factorial_recursive(n-1)
}

function factorial_iterative(n) {
    function _factorial_iterative(cumulative_value, steps) {
        return (
            steps === n
            ? cumulative_value * n
            : _factorial_iterative(cumulative_value*steps, steps+1)
        )
    }

    return _factorial_iterative(1, 1)
}


// Ex 1.9
function inc(a) {
    return a + 1;
}
function dec(b) {
    return b - 1;
}

// This one is iterative (at each step only state variables are needed)
function plus_1(a, b) {
    return a === 0 ? b : plus_1(dec(a), inc(b));
}

// This one is recursive (all the process history is needed for the calculation)
function plus_2(a, b) {
    return a === 0 ? b : inc(plus_2(dec(a), b))
}

// Ex 1.10: Ackermann's function

function ackermann(x, y) {
    return (
        y === 0
        ? 0
        : x === 0
        ? 2 * y
        : y === 1
        ? 2
        : ackermann(x-1, ackermann(x, y-1))
    )
}

ackermann(1, 10) === 1024
ackermann(2, 4) === 65536
ackermann(3, 3) === 65536

// Functions generated by Ackermann
function f(n) {
    return ackermann(0, n)
}

// mathematically equivalent to
function double(n) {
    return 2 * n;
}


function g(n) {
    return ackermann(1, n);
}

// mathematical equivalent
function two_to_the_power(n) {
    return 2**n;
}


function h(n) {
    return ackermann(2, n);
}

function raise(n) {
    return n === 1 ? 2 : 2**raise(n-1);
}